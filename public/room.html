<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call Room</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üìπ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .video-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 1rem;
            height: calc(100vh - 120px);
            overflow: hidden;
        }
        
        .video-wrapper {
            position: relative;
            background: #0f0f1e;
            border-radius: 15px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            max-height: 100%;
            height: 100%;
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }
        
        .video-label {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .controls {
            background: #16213e;
            padding: 1rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            flex-shrink: 0;
            min-height: 80px;
            max-height: 120px;
        }
        
        .control-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .control-btn.primary {
            background: #667eea;
        }
        
        .control-btn.primary:hover {
            background: #5a67d8;
        }
        
        .control-btn.danger {
            background: #e53e3e;
        }
        
        .control-btn.danger:hover {
            background: #c53030;
        }
        
        .control-btn.success {
            background: #48bb78;
        }
        
        .control-btn.success:hover {
            background: #38a169;
        }
        
        .control-btn.warning {
            background: #ed8936;
        }
        
        .control-btn.warning:hover {
            background: #dd6b20;
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .status {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            z-index: 1000;
        }
        
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: #e53e3e;
            font-weight: 500;
        }
        
        .recording-indicator.active {
            display: flex;
        }
        
        .recording-dot {
            width: 10px;
            height: 10px;
            background: #e53e3e;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }
        
        .placeholder {
            color: #666;
            font-size: 1.2rem;
        }
        
        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr;
                height: calc(100vh - 140px);
            }
        }
        
        @media (max-height: 700px) {
            .video-container {
                height: calc(100vh - 100px);
            }
            
            .control-btn {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
            
            .controls {
                padding: 0.75rem;
                gap: 0.75rem;
                min-height: 60px;
                max-height: 100px;
            }
        }
        
        @media (max-height: 500px) {
            .video-container {
                grid-template-columns: 1fr 1fr;
                height: calc(100vh - 80px);
            }
            
            .control-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.85rem;
            }
            
            .controls {
                padding: 0.5rem;
                gap: 0.5rem;
                min-height: 50px;
                max-height: 80px;
            }
            
            .status {
                font-size: 0.9rem;
                padding: 0.5rem 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="status" id="status">Connecting...</div>
    
    <div class="video-container">
        <div class="video-wrapper">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="video-label" id="localLabel">You</div>
        </div>
        <div class="video-wrapper">
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="video-label" id="remoteLabel">Remote User</div>
            <div class="placeholder" id="placeholder">Waiting for other user...</div>
        </div>
    </div>
    
    <div class="controls">
        <button class="control-btn primary" id="toggleVideo">
            <span>üìπ</span> Turn Off Video
        </button>
        <button class="control-btn primary" id="toggleAudio">
            <span>üé§</span> Mute Audio
        </button>
        <button class="control-btn success" id="startRecording">
            <span>‚è∫Ô∏è</span> Start Recording
        </button>
        <button class="control-btn warning" id="stopRecording" style="display: none;">
            <span>‚èπÔ∏è</span> Stop Recording
        </button>
        <button class="control-btn danger" id="endCall">
            <span>üìû</span> End Call
        </button>
        <div class="recording-indicator" id="recordingIndicator">
            <div class="recording-dot"></div>
            <span>Recording...</span>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Configure Socket.IO for ngrok
        const socketOptions = {};
        if (window.location.hostname.includes('ngrok')) {
            socketOptions.transports = ['websocket', 'polling'];
        }
        const socket = io(socketOptions);
        const roomId = window.location.pathname.split('/').pop();
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const status = document.getElementById('status');
        const placeholder = document.getElementById('placeholder');
        
        let localStream;
        let remoteStream;
        let peerConnection;
        let mediaRecorder;
        let recordedChunks = [];
        let makingOffer = false;
        let ignoreOffer = false;
        let isSettingRemoteAnswerPending = false;
        let pendingCandidates = [];
        
        // Progressive recording variables
        let localAudioRecorder;
        let remoteAudioRecorder;
        let chunkIndex = 0;
        let recordingStartTime;
        let isProgressiveRecording = false;
        
        // Check if this user is the interviewer (room creator)
        // Check URL parameter first, then session storage
        const urlParams = new URLSearchParams(window.location.search);
        const isCreator = urlParams.get('creator') === 'true';
        const isInterviewer = isCreator || sessionStorage.getItem(`room_creator_${roomId}`) === 'true';
        
        // Store in session if creator
        if (isCreator) {
            sessionStorage.setItem(`room_creator_${roomId}`, 'true');
        }
        
        // Update labels and hide recording controls based on role
        if (!isInterviewer) {
            document.getElementById('startRecording').style.display = 'none';
            document.getElementById('stopRecording').style.display = 'none';
            document.getElementById('recordingIndicator').style.display = 'none';
            document.getElementById('localLabel').textContent = 'You (Interviewee)';
            document.getElementById('remoteLabel').textContent = 'Interviewer';
            console.log('You are the interviewee - recording controls hidden');
        } else {
            document.getElementById('localLabel').textContent = 'You (Interviewer)';
            document.getElementById('remoteLabel').textContent = 'Interviewee';
            console.log('You are the interviewer - recording controls available');
        }
        
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // Public TURN servers (these are free but less reliable)
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10
        };
        
        async function initializeMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                // Ensure local video is muted to prevent echo
                localVideo.muted = true;
                localVideo.volume = 0;
                status.textContent = 'Connected - Waiting for peer...';
            } catch (error) {
                console.error('Error accessing media devices:', error);
                status.textContent = 'Error: Could not access camera/microphone';
            }
        }
        
        function createPeerConnection(userId) {
            console.log('Creating peer connection for:', userId);
            peerConnection = new RTCPeerConnection(configuration);
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    console.log('Adding track to peer connection:', track.kind);
                    peerConnection.addTrack(track, localStream);
                });
            } else {
                console.error('No local stream available when creating peer connection');
            }
            
            peerConnection.ontrack = (event) => {
                console.log('Received remote track:', event.track.kind);
                console.log('Remote streams:', event.streams.length);
                if (event.streams && event.streams[0]) {
                    console.log('Setting remote video stream');
                    remoteVideo.srcObject = event.streams[0];
                    remoteStream = event.streams[0];
                    placeholder.style.display = 'none';
                    status.textContent = 'Connected - Call active';
                    
                    // Auto-start recording when both streams are available
                    // Uncomment this to automatically start recording
                    // if (localStream && remoteStream && !isProgressiveRecording) {
                    //     setTimeout(() => startProgressiveRecording(), 1000);
                    // }
                } else {
                    console.error('No streams in track event');
                }
            };
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate.type);
                    socket.emit('ice-candidate', event.candidate, userId);
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
                switch(peerConnection.iceConnectionState) {
                    case 'checking':
                        status.textContent = 'Connecting...';
                        break;
                    case 'connected':
                    case 'completed':
                        status.textContent = 'Connected - Call active';
                        break;
                    case 'failed':
                        status.textContent = 'Connection failed - Try refreshing';
                        console.error('ICE connection failed');
                        break;
                    case 'disconnected':
                        status.textContent = 'Connection lost - Reconnecting...';
                        break;
                }
            };
            
            peerConnection.onicegatheringstatechange = () => {
                console.log('ICE gathering state:', peerConnection.iceGatheringState);
            };
            
            return peerConnection;
        }
        
        async function makeOffer(userId) {
            try {
                console.log('Making offer to:', userId);
                makingOffer = true;
                const pc = createPeerConnection(userId);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                console.log('Sending offer to:', userId);
                socket.emit('offer', pc.localDescription, userId);
            } catch (err) {
                console.error('Error making offer:', err);
            } finally {
                makingOffer = false;
            }
        }
        
        socket.emit('join-room', roomId);
        console.log('Joining room:', roomId);
        
        socket.on('other-users', async (users) => {
            console.log('Other users in room:', users);
            await initializeMedia();
            if (users.length > 0) {
                console.log('I am the new user, making offers to existing users');
                // New user makes offers to existing users
                users.forEach(userId => {
                    setTimeout(() => makeOffer(userId), 100);
                });
            } else {
                console.log('I am the first user in the room');
            }
        });
        
        socket.on('user-joined', async (userId) => {
            console.log('New user joined:', userId);
            if (!localStream) {
                await initializeMedia();
            }
            // Existing users don't make offers, they wait for the new user to offer
            console.log('Waiting for offer from new user:', userId);
        });
        
        socket.on('offer', async (offer, userId) => {
            try {
                console.log('Received offer from:', userId);
                if (!localStream) {
                    console.log('Initializing media before answering');
                    await initializeMedia();
                }
                
                // Remove collision detection - we now control who makes offers
                // const offerCollision = (offer.type === 'offer') && 
                //                      (makingOffer || peerConnection?.signalingState !== 'stable');
                
                // ignoreOffer = offerCollision;
                // if (ignoreOffer) {
                //     console.log('Ignoring offer due to collision');
                //     return;
                // }
                
                if (!peerConnection) {
                    peerConnection = createPeerConnection(userId);
                }
                
                await peerConnection.setRemoteDescription(offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Sending answer to:', userId);
                socket.emit('answer', peerConnection.localDescription, userId);
                
                // Process any pending ICE candidates
                if (pendingCandidates.length > 0) {
                    for (const candidate of pendingCandidates) {
                        await peerConnection.addIceCandidate(candidate);
                    }
                    pendingCandidates = [];
                }
            } catch (err) {
                console.error('Error handling offer:', err);
            }
        });
        
        socket.on('answer', async (answer) => {
            try {
                console.log('Received answer, signaling state:', peerConnection?.signalingState);
                const readyForAnswer = !makingOffer && 
                                      (peerConnection?.signalingState === 'have-local-offer' || 
                                       isSettingRemoteAnswerPending);
                if (!readyForAnswer) {
                    console.log('Not ready for answer, ignoring. State:', peerConnection?.signalingState);
                    return;
                }
                
                isSettingRemoteAnswerPending = true;
                console.log('Setting remote description (answer)');
                await peerConnection.setRemoteDescription(answer);
                
                // Process any pending ICE candidates
                if (pendingCandidates.length > 0) {
                    for (const candidate of pendingCandidates) {
                        await peerConnection.addIceCandidate(candidate);
                    }
                    pendingCandidates = [];
                }
            } catch (err) {
                console.error('Error handling answer:', err);
            } finally {
                isSettingRemoteAnswerPending = false;
            }
        });
        
        socket.on('ice-candidate', async (candidate) => {
            try {
                if (!peerConnection) {
                    pendingCandidates.push(candidate);
                    return;
                }
                
                if (!peerConnection.remoteDescription) {
                    pendingCandidates.push(candidate);
                    return;
                }
                
                await peerConnection.addIceCandidate(candidate);
                
                // Process any pending candidates
                if (pendingCandidates.length > 0) {
                    for (const pendingCandidate of pendingCandidates) {
                        await peerConnection.addIceCandidate(pendingCandidate);
                    }
                    pendingCandidates = [];
                }
            } catch (err) {
                console.error('Error adding ICE candidate:', err);
            }
        });
        
        socket.on('user-left', () => {
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                remoteVideo.srcObject = null;
            }
            placeholder.style.display = 'block';
            status.textContent = 'User disconnected';
        });
        
        document.getElementById('toggleVideo').addEventListener('click', () => {
            if (!localStream) {
                console.log('No local stream available');
                return;
            }
            
            const videoTracks = localStream.getVideoTracks();
            if (videoTracks.length > 0) {
                const videoTrack = videoTracks[0];
                const isEnabled = videoTrack.enabled;
                videoTrack.enabled = !isEnabled;
                
                const button = document.getElementById('toggleVideo');
                if (!videoTrack.enabled) {
                    button.innerHTML = '<span>üì∑</span> Turn On Video';
                    button.style.background = '#e53e3e'; // Red when off
                    console.log('Camera turned off');
                } else {
                    button.innerHTML = '<span>üìπ</span> Turn Off Video';
                    button.style.background = '#667eea'; // Original color when on
                    console.log('Camera turned on');
                }
            } else {
                console.log('No video tracks found');
            }
        });
        
        document.getElementById('toggleAudio').addEventListener('click', () => {
            if (!localStream) {
                console.log('No local stream available');
                return;
            }
            
            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length > 0) {
                const audioTrack = audioTracks[0];
                const isEnabled = audioTrack.enabled;
                audioTrack.enabled = !isEnabled;
                
                const button = document.getElementById('toggleAudio');
                if (!audioTrack.enabled) {
                    button.innerHTML = '<span>üîá</span> Unmute Audio';
                    button.style.background = '#e53e3e'; // Red when muted
                    console.log('Microphone muted');
                } else {
                    button.innerHTML = '<span>üé§</span> Mute Audio';
                    button.style.background = '#667eea'; // Original color when active
                    console.log('Microphone unmuted');
                }
            } else {
                console.log('No audio tracks found');
            }
        });
        
        document.getElementById('startRecording').addEventListener('click', () => {
            startProgressiveRecording();
        });
        
        document.getElementById('stopRecording').addEventListener('click', () => {
            stopProgressiveRecording();
        });
        
        document.getElementById('endCall').addEventListener('click', () => {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
            }
            window.location.href = '/';
        });
        
        // Progressive recording functions
        function startProgressiveRecording() {
            if (!localStream) {
                console.error('Cannot start recording: No local stream available');
                alert('Please allow camera/microphone access first');
                return;
            }
            
            if (!remoteStream) {
                console.warn('Warning: No remote stream yet, but starting recording with local stream only');
                // Continue anyway - we can still record the local side
            }
            
            isProgressiveRecording = true;
            recordingStartTime = Date.now();
            chunkIndex = 0;
            
            // Record local audio only
            const localAudioStream = new MediaStream();
            localStream.getAudioTracks().forEach(track => localAudioStream.addTrack(track));
            
            // Record remote audio only if available
            const remoteAudioStream = new MediaStream();
            if (remoteStream) {
                remoteStream.getAudioTracks().forEach(track => remoteAudioStream.addTrack(track));
            }
            
            // Start local audio recorder
            if (localAudioStream.getAudioTracks().length > 0) {
                localAudioRecorder = new MediaRecorder(localAudioStream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 128000
                });
                
                localAudioRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        uploadChunk(event.data, 'local', chunkIndex);
                    }
                };
                
                localAudioRecorder.start(30000); // 30 second chunks
                console.log('Started recording local audio');
            }
            
            // Start remote audio recorder
            if (remoteAudioStream.getAudioTracks().length > 0) {
                remoteAudioRecorder = new MediaRecorder(remoteAudioStream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 128000
                });
                
                remoteAudioRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        uploadChunk(event.data, 'remote', chunkIndex);
                    }
                };
                
                remoteAudioRecorder.start(30000); // 30 second chunks
                console.log('Started recording remote audio');
            }
            
            // Increment chunk index every 30 seconds
            setInterval(() => {
                if (isProgressiveRecording) {
                    chunkIndex++;
                }
            }, 30000);
            
            // Update UI
            document.getElementById('startRecording').style.display = 'none';
            document.getElementById('stopRecording').style.display = 'inline-flex';
            document.getElementById('recordingIndicator').classList.add('active');
            
            console.log('üî¥ RECORDING STARTED - Chunks will upload every 30 seconds');
            console.log(`Room ID: ${roomId}`);
            console.log(`Local audio: ${localAudioRecorder ? 'Recording' : 'Not recording'}`);
            console.log(`Remote audio: ${remoteAudioRecorder ? 'Recording' : 'Not recording'}`);
        }
        
        function stopProgressiveRecording() {
            isProgressiveRecording = false;
            
            if (localAudioRecorder && localAudioRecorder.state !== 'inactive') {
                localAudioRecorder.stop();
            }
            
            if (remoteAudioRecorder && remoteAudioRecorder.state !== 'inactive') {
                remoteAudioRecorder.stop();
            }
            
            // Notify server that recording is complete
            fetch('/api/recording-complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    roomId: roomId,
                    totalChunks: chunkIndex + 1,
                    duration: Date.now() - recordingStartTime
                })
            });
            
            // Update UI
            document.getElementById('startRecording').style.display = 'inline-flex';
            document.getElementById('stopRecording').style.display = 'none';
            document.getElementById('recordingIndicator').classList.remove('active');
            
            console.log('Stopped progressive recording');
        }
        
        async function uploadChunk(blob, streamType, index) {
            console.log(`üì§ Uploading ${streamType} chunk ${index}, size: ${blob.size} bytes`);
            
            const formData = new FormData();
            formData.append('audio', blob, `${streamType}_chunk_${index}.webm`);
            formData.append('roomId', roomId);
            formData.append('streamType', streamType);
            formData.append('chunkIndex', index);
            formData.append('timestamp', Date.now());
            
            try {
                // Try regular fetch first
                const response = await fetch('/api/upload-chunk', {
                    method: 'POST',
                    body: formData,
                    keepalive: true
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`‚úÖ Uploaded ${streamType} chunk ${index} successfully`);
                } else {
                    const error = await response.text();
                    console.error(`‚ùå Failed to upload ${streamType} chunk ${index}: ${error}`);
                }
            } catch (error) {
                console.error(`‚ùå Failed to upload ${streamType} chunk ${index}:`, error);
                // Try sendBeacon as fallback
                if (navigator.sendBeacon) {
                    console.log('Trying sendBeacon fallback...');
                    navigator.sendBeacon('/api/upload-chunk', formData);
                }
            }
        }
        
        window.addEventListener('beforeunload', (e) => {
            // Emergency upload of any remaining data
            if (isProgressiveRecording) {
                // Force stop recorders to get final chunks
                if (localAudioRecorder && localAudioRecorder.state === 'recording') {
                    localAudioRecorder.stop();
                }
                if (remoteAudioRecorder && remoteAudioRecorder.state === 'recording') {
                    remoteAudioRecorder.stop();
                }
                
                // Notify server of abrupt end
                const formData = new FormData();
                formData.append('roomId', roomId);
                formData.append('abruptEnd', 'true');
                formData.append('lastChunk', chunkIndex);
                
                if (navigator.sendBeacon) {
                    navigator.sendBeacon('/api/recording-abort', formData);
                }
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
            }
        });
    </script>
</body>
</html>